## Progressive Web App Features

The application is built as a Progressive Web App (PWA) with modern web capabilities.

### Key Files

- public/service-worker.js: Service worker for PWA functionality
- client/src/components/common/OfflineDetector.tsx: Offline mode detection
- client/src/hooks/use-offline-db.tsx: Hook for offline database access
- workbox-config.js: Workbox configuration for service worker

### PWA Capabilities

1. Offline Functionality:
   - App works without internet connection
   - Data is synced when connection is restored
   - Critical features work offline

2. Installability:
   - App can be installed on desktop and mobile devices
   - App manifest defines appearance
   - Install prompt is shown to users

3. Push Notifications:
   - Results notifications
   - Winning notifications
   - Special announcements

4. Background Sync:
   - Bets are synced when online
   - Transactions are synchronized
   - Data is kept consistent

### Service Worker Implementation (public/service-worker.js)

```javascript
// Workbox imports
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');

// Workbox configuration
workbox.core.setCacheNameDetails({
  prefix: 'shillong-teer',
  suffix: 'v1',
  precache: 'precache',
  runtime: 'runtime',
});

// Skip waiting and claim clients
self.skipWaiting();
workbox.core.clientsClaim();

// Precache assets
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);

// Cache static assets
workbox.routing.registerRoute(
  ({ request }) => request.destination === 'style' ||
                   request.destination === 'script' ||
                   request.destination === 'font' ||
                   request.destination === 'image',
  new workbox.strategies.CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache API responses with network first strategy
workbox.routing.registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  networkFirstWithTimeout(new workbox.strategies.NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }), 3000) // 3-second timeout
);

// Default page handler for navigations
workbox.routing.registerRoute(
  ({ request }) => request.mode === 'navigate',
  async ({ event }) => {
    try {
      // Try to get the cached page
      const cachedResponse = await caches.match('/index.html');
      
      if (cachedResponse) {
        return cachedResponse;
      }
      
      // If not cached, fetch it
      const response = await fetch('/index.html');
      
      // Cache the network response
      const cache = await caches.open('pages');
      cache.put('/index.html', response.clone());
      
      return response;
    } catch (error) {
      // If both cache and network fail, return a fallback
      return caches.match('/offline.html');
    }
  }
);

// Custom network-first with timeout strategy
function networkFirstWithTimeout(strategy, timeoutMs) {
  return async (options) => {
    const [timeoutPromise, timeoutId] = createTimedOutPromise(timeoutMs);
    
    try {
      // Try network first
      const networkPromise = strategy.handle(options);
      const response = await Promise.race([networkPromise, timeoutPromise]);
      
      if (response) {
        clearTimeout(timeoutId);
        return response;
      }
      
      // If network takes too long, use cache
      const cacheResponse = await caches.match(options.request);
      
      if (cacheResponse) {
        return cacheResponse;
      }
      
      // If no cache, wait for network (but might have already failed)
      return await networkPromise;
    } catch (error) {
      // If network fails, try cache
      clearTimeout(timeoutId);
      const cacheResponse = await caches.match(options.request);
      
      if (cacheResponse) {
        return cacheResponse;
      }
      
      throw error;
    }
  };
}

// Create a promise that times out
function createTimedOutPromise(timeoutMs) {
  let timeoutId;
  const timeoutPromise = new Promise((resolve) => {
    timeoutId = setTimeout(() => resolve(null), timeoutMs);
  });
  
  return [timeoutPromise, timeoutId];
}

// Offline data synchronization
let syncInProgress = false;

// Listen for sync events
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-bets') {
    event.waitUntil(syncOfflineData());
  }
});

// Background sync function
async function syncOfflineData() {
  if (syncInProgress) return;
  
  syncInProgress = true;
  
  try {
    // Send offline data to server
    await Promise.all([
      syncBets(),
      // Add other sync functions as needed
    ]);
    
    // Notify clients about successful sync
    const clients = await self.clients.matchAll({ type: 'window' });
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETED',
        timestamp: new Date().toISOString(),
      });
    });
  } catch (error) {
    console.error('Sync failed:', error);
    
    // Notify clients about sync failure
    const clients = await self.clients.matchAll({ type: 'window' });
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_FAILED',
        error: error.message,
        timestamp: new Date().toISOString(),
      });
    });
  } finally {
    syncInProgress = false;
  }
}

// Sync bets from IndexedDB to server
async function syncBets() {
  // Open IndexedDB
  const db = await openDB();
  
  // Get offline bets
  const offlineBets = await db.getAll('offlineBets');
  
  if (offlineBets.length === 0) {
    return;
  }
  
  // Send each bet to server
  const results = await Promise.allSettled(
    offlineBets.map(async (bet) => {
      try {
        // Send bet to server
        const response = await fetch('/api/bets', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(bet),
        });
        
        if (!response.ok) {
          throw new Error(`Failed to sync bet: ${response.statusText}`);
        }
        
        // Remove from offline store
        await db.delete('offlineBets', bet.id);
        
        return { status: 'fulfilled', bet };
      } catch (error) {
        return { status: 'rejected', bet, error };
      }
    })
  );
  
  // Count successes and failures
  const succeeded = results.filter(r => r.status === 'fulfilled').length;
  const failed = results.filter(r => r.status === 'rejected').length;
  
  // Notify clients about sync results
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach(client => {
    client.postMessage({
      type: 'BETS_SYNCED',
      succeeded,
      failed,
      timestamp: new Date().toISOString(),
    });
  });
  
  return { succeeded, failed };
}

// Helper function to open IndexedDB
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('shillong-teer-offline', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Create object stores if they don't exist
      if (!db.objectStoreNames.contains('offlineBets')) {
        db.createObjectStore('offlineBets', { keyPath: 'id' });
      }
    };
  });
}

// Listen for push notifications
self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  try {
    const data = event.data.json();
    
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      data: {
        url: data.url || '/',
      },
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  } catch (error) {
    console.error('Push notification error:', error);
  }
});

// Notification click event
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Check if there's already a window open
      for (const client of clientList) {
        if (client.url === event.notification.data.url && 'focus' in client) {
          return client.focus();
        }
      }
      
      // If no window is open, open a new one
      if (clients.openWindow) {
        return clients.openWindow(event.notification.data.url);
      }
    })
  );
});
```

### Offline Mode Detection (client/src/components/common/OfflineDetector.tsx)

```tsx
export interface OfflineStatus {
  isOffline: boolean;
  lastSyncTime: Date | null;
  pendingSyncItems: number;
}

export const offlineStatus: OfflineStatus = {
  isOffline: !navigator.onLine,
  lastSyncTime: null,
  pendingSyncItems: 0,
};

export default function OfflineDetector() {
  const [isOffline, setIsOffline] = useState(!navigator.onLine);
  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);
  const [pendingSyncItems, setPendingSyncItems] = useState(0);
  const { db } = useOfflineDB();
  const { toast } = useToast();

  // Update offline status when connection changes
  useEffect(() => {
    const handleOnline = () => {
      setIsOffline(false);
      offlineStatus.isOffline = false;
      
      toast({
        title: 'Back online',
        description: 'Your connection has been restored. Syncing data...',
      });
      
      // Trigger background sync
      navigator.serviceWorker.ready.then((registration) => {
        registration.sync.register('sync-bets');
      });
    };
    
    const handleOffline = () => {
      setIsOffline(true);
      offlineStatus.isOffline = true;
      
      toast({
        variant: 'destructive',
        title: 'You are offline',
        description: 'Some features may be limited. Data will be synced when you reconnect.',
      });
    };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [toast]);
  
  // Count pending offline items
  useEffect(() => {
    if (!db) return;
    
    const checkPendingItems = async () => {
      try {
        const bets = await getOfflineItems(db, 'offlineBets');
        setPendingSyncItems(bets.length);
        offlineStatus.pendingSyncItems = bets.length;
      } catch (error) {
        console.error('Error checking pending items:', error);
      }
    };
    
    checkPendingItems();
    
    // Check periodically
    const interval = setInterval(checkPendingItems, 30000);
    
    return () => clearInterval(interval);
  }, [db]);
  
  // Listen for service worker messages
  useEffect(() => {
    const handleServiceWorkerMessage = (event: MessageEvent) => {
      const data = event.data;
      
      if (data.type === 'SYNC_COMPLETED') {
        setLastSyncTime(new Date(data.timestamp));
        offlineStatus.lastSyncTime = new Date(data.timestamp);
        
        toast({
          title: 'Sync completed',
          description: 'Your data has been synced with the server.',
        });
      } else if (data.type === 'SYNC_FAILED') {
        toast({
          variant: 'destructive',
          title: 'Sync failed',
          description: data.error || 'Failed to sync data with the server.',
        });
      } else if (data.type === 'BETS_SYNCED') {
        if (data.succeeded > 0) {
          toast({
            title: 'Bets synced',
            description: `${data.succeeded} bets synced, ${data.failed} failed.`,
          });
        }
      }
    };
    
    navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
    
    return () => {
      navigator.serviceWorker.removeEventListener('message', handleServiceWorkerMessage);
    };
  }, [toast]);
  
  // Only render the indicator if offline or there are pending sync items
  if (!isOffline && pendingSyncItems === 0) {
    return null;
  }
  
  return (
    <div className="fixed bottom-4 right-4 z-50">
      <div className="bg-gray-800 rounded-lg shadow-lg p-3 text-white flex items-center">
        {isOffline ? (
          <>
            <WifiOffIcon className="h-5 w-5 mr-2 text-red-500" />
            <span>Offline Mode</span>
          </>
        ) : pendingSyncItems > 0 ? (
          <>
            <CloudSyncIcon className="h-5 w-5 mr-2 text-yellow-500 animate-spin" />
            <span>Syncing {pendingSyncItems} items...</span>
          </>
        ) : null}
      </div>
    </div>
  );
}
```

### Offline Database Hook (client/src/hooks/use-offline-db.tsx)

```tsx
interface UseOfflineDBResult {
  db: IDBDatabase | null;
  isLoading: boolean;
  error: Error | null;
}

/**
 * Hook to access IndexedDB for offline storage
 */
export function useOfflineDB(): UseOfflineDBResult {
  const [db, setDb] = useState<IDBDatabase | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    let isMounted = true;
    
    const openDatabase = async () => {
      try {
        const request = indexedDB.open('shillong-teer-offline', 1);
        
        request.onupgradeneeded = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;
          
          // Create object stores if they don't exist
          if (!db.objectStoreNames.contains('offlineBets')) {
            db.createObjectStore('offlineBets', { keyPath: 'id' });
          }
          
          // Add other stores as needed
        };
        
        request.onsuccess = () => {
          if (isMounted) {
            setDb(request.result);
            setIsLoading(false);
          }
        };
        
        request.onerror = () => {
          if (isMounted) {
            setError(new Error('Failed to open IndexedDB'));
            setIsLoading(false);
          }
        };
      } catch (e) {
        if (isMounted) {
          setError(e instanceof Error ? e : new Error('Unknown error opening IndexedDB'));
          setIsLoading(false);
        }
      }
    };
    
    openDatabase();
    
    return () => {
      isMounted = false;
      if (db) {
        db.close();
      }
    };
  }, []);
  
  return { db, isLoading, error };
}

/**
 * Store an item in IndexedDB
 */
export async function storeOfflineItem<T>(
  db: IDBDatabase, 
  storeName: string, 
  item: T
): Promise<T> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    
    // Generate unique ID if not present
    if (!('id' in item as any)) {
      (item as any).id = Date.now() + Math.random().toString(36).substring(2, 9);
    }
    
    const request = store.add(item);
    
    request.onsuccess = () => resolve(item);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Retrieve items from IndexedDB
 */
export async function getOfflineItems<T>(
  db: IDBDatabase, 
  storeName: string
): Promise<T[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Delete an item from IndexedDB
 */
export async function deleteOfflineItem(
  db: IDBDatabase, 
  storeName: string, 
  id: string | number
): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

/**
 * Clear all items from a store
 */
export async function clearOfflineStore(
  db: IDBDatabase, 
  storeName: string
): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.clear();
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}
```

### Offline Betting Flow

The application supports placing bets while offline:

```tsx
// Modified betting form with offline support
function BettingForm({ /* props */ }) {
  // ... other state
  
  const { db, isLoading: isDbLoading } = useOfflineDB();
  const isOffline = !navigator.onLine;
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate bet (same validation logic as before)
    
    // If offline, store bet in IndexedDB
    if (isOffline && db) {
      try {
        const offlineBet = {
          id: Date.now() + Math.random().toString(36).substring(2, 9),
          userId: user?.id,
          numbers: selectedNumbers.map(n => n.toString().padStart(2, '0')),
          amount: betAmount,
          round: selectedRound,
          date: new Date(),
          status: 'pending',
          createdOffline: true,
        };
        
        await storeOfflineItem(db, 'offlineBets', offlineBet);
        
        toast({
          title: 'Bet stored offline',
          description: 'Your bet has been stored and will be placed when you reconnect.',
        });
        
        onResetSelection();
      } catch (error) {
        toast({
          variant: 'destructive',
          title: 'Failed to store bet',
          description: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    } else {
      // Online - place bet normally
      placeBetMutation.mutate();
    }
  };
  
  // ... rest of the component
}
```

### Web App Manifest

The application uses a web app manifest for PWA installation:

```json
{
  "name": "Shillong Teer",
  "short_name": "Teer",
  "description": "Shillong Teer betting application",
  "theme_color": "#121212",
  "background_color": "#121212",
  "display": "standalone",
  "orientation": "portrait",
  "scope": "/",
  "start_url": "/",
  "icons": [
    {
      "src": "icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    },
    {
      "src": "icons/maskable-icon.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ]
}
```

### Workbox Configuration (workbox-config.js)

```javascript
module.exports = {
  globDirectory: 'dist',
  globPatterns: [
    '**/*.{html,js,css,png,jpg,jpeg,gif,svg,woff,woff2,eot,ttf,otf}'
  ],
  swDest: 'dist/service-worker.js',
  swSrc: 'public/service-worker.js',
  maximumFileSizeToCacheInBytes: 5 * 1024 * 1024, // 5 MB
};
```
